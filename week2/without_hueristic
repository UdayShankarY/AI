from collections import deque

def input_state(prompt):
    print("Uday Shankar Y\n1BM24CS427")
    print(prompt)
    state = []
    for _ in range(3):
        row = input().strip().split()
        if len(row) != 3:
            raise ValueError("Each row must have exactly 3 numbers")
        state.extend(row)
    return tuple(state)

def print_state(state):
    for i in range(0, 9, 3):
        print(' '.join(state[i:i+3]))
    print()

def get_neighbors_with_moves(state):
    neighbors = []
    zero_index = state.index('0')
    r, c = zero_index // 3, zero_index % 3

    moves = [(-1,0,'UP'), (1,0,'DOWN'), (0,-1,'LEFT'), (0,1,'RIGHT')]
    for dr, dc, move_name in moves:
        nr, nc = r + dr, c + dc
        if 0 <= nr < 3 and 0 <= nc < 3:
            new_index = nr * 3 + nc
            new_state = list(state)
            new_state[zero_index], new_state[new_index] = new_state[new_index], new_state[zero_index]
            neighbors.append((tuple(new_state), move_name))

    return neighbors

def is_solvable(state):
    lst = [int(x) for x in state if x != '0']
    inv_count = 0
    for i in range(len(lst)):
        for j in range(i+1, len(lst)):
            if lst[i] > lst[j]:
                inv_count += 1
    return inv_count % 2 == 0

def bfs(start, goal):
    queue = deque([(start, [], [], 0)])  # (state, path_states, path_moves, cost)
    visited = set([start])
    visited_count = 1

    while queue:
        current, path_states, path_moves, cost = queue.popleft()
        if current == goal:
            return path_states + [current], path_moves, cost, visited_count
        for neighbor, move in get_neighbors_with_moves(current):
            if neighbor not in visited:
                visited.add(neighbor)
                visited_count += 1
                queue.append((neighbor, path_states + [current], path_moves + [move], cost + 1))
    return None, None, None, visited_count

def dfs(start, goal, max_depth=50):
    stack = [(start, [], [], 0, 0)]  # (state, path_states, path_moves, cost, depth)
    visited = set([start])
    visited_count = 1

    while stack:
        current, path_states, path_moves, cost, depth = stack.pop()
        if current == goal:
            return path_states + [current], path_moves, cost, visited_count
        if depth < max_depth:
            for neighbor, move in get_neighbors_with_moves(current):
                if neighbor not in visited:
                    visited.add(neighbor)
                    visited_count += 1
                    stack.append((neighbor, path_states + [current], path_moves + [move], cost + 1, depth + 1))
    return None, None, None, visited_count

def main():
    try:
        initial_state = input_state("Enter the initial state (3 rows, 3 numbers each, use 0 for blank):")
        goal_state = input_state("Enter the goal state (3 rows, 3 numbers each, use 0 for blank):")
    except ValueError as e:
        print(f"Invalid input: {e}")
        return

    if not is_solvable(initial_state):
        print("This initial state is unsolvable!")
        return
    if not is_solvable(goal_state):
        print("This goal state is unsolvable!")
        return

    method = input("Enter search method (bfs or dfs): ").strip().lower()
    if method not in ['bfs', 'dfs']:
        print("Invalid method. Please enter 'bfs' or 'dfs'.")
        return

    print("\nSearching...\n")
    if method == 'bfs':
        states, moves, cost, visited_count = bfs(initial_state, goal_state)
    else:
        states, moves, cost, visited_count = dfs(initial_state, goal_state)

    if states is None:
        print("No solution found.")
    else:
        print(f"Solution found with cost {cost} moves.")
        print(f"Total visited states: {visited_count}\n")

        # Print initial state
        print("Step 0:")
        print_state(states[0])

        # Print moves and subsequent states
        for i in range(1, len(states)):
            print(f"Move {i}: {moves[i-1]}")
            print_state(states[i])

if __name__ == "__main__":
    main()
